#include <iostream>
#include <fstream>
#include <sstream>
#include <cmath>
#include <stdlib.h>     /* system, exit, EXIT_FAILURE */

#include "exporter.h"
#include "lodepng.h"

exporter::exporter(mesh* p_msh) : p_mesh(p_msh) 
{ 
  this->initialize();
}

// ---------------------------------------------

void exporter::initialize()
{
  // Creates a directory named 'output', into the working directory,
  // where stuff is exported
  system("mkdir -p ./output");
}

// ---------------------------------------------

void exporter::export_mesh_VTK(const char* filename)
{
  cell* p_cell_now; // pointer to cell
  double x1now, x2now, x3now, x4now;
  double y1now, y2now, y3now, y4now;

  size_t n_cells = p_mesh->get_n_cells();

  std::ofstream fileVTK;
  fileVTK.open(filename, std::ios::trunc); // open the file (destroy if exists)
  if (fileVTK.is_open() == 1) // file correctly initialized
  { 
    // writing VTK stuff
    fileVTK << "# vtk DataFile Version 2.0\n";
    fileVTK << "Generated by VTKer\n";
    fileVTK << "ASCII\n";
    fileVTK << "DATASET UNSTRUCTURED_GRID\n";
    fileVTK << "POINTS " << 4*n_cells << " float\n";
    for(int ii = 0; ii < n_cells; ii++)
    {
      p_cell_now = &(p_mesh->cells.at(ii));
      x1now = p_cell_now->XYZcorners[0];
      x2now = p_cell_now->XYZcorners[1];
      x3now = p_cell_now->XYZcorners[1];
      x4now = p_cell_now->XYZcorners[0];
  
      y1now = p_cell_now->XYZcorners[2];
      y2now = p_cell_now->XYZcorners[2];
      y3now = p_cell_now->XYZcorners[3];
      y4now = p_cell_now->XYZcorners[3];
  
      fileVTK << x1now << " " << y1now << " 0   ";
      fileVTK << x2now << " " << y2now << " 0   ";
      fileVTK << x3now << " " << y3now << " 0   ";
      fileVTK << x4now << " " << y4now << " 0   ";
      fileVTK << "\n";
    }
  
    fileVTK << "\n";
    fileVTK << "CELLS " << n_cells << " " << 5*n_cells << "\n";
    for(int ii = 0; ii < n_cells; ii++)
    {
      fileVTK << "4 ";
      fileVTK << 0 + 4*ii << " ";
      fileVTK << 1 + 4*ii << " ";
      fileVTK << 2 + 4*ii << " ";
      fileVTK << 3 + 4*ii << " ";
      fileVTK << "\n";
    }
  
    fileVTK << "\n";
    fileVTK << "CELL_TYPES " << n_cells << "\n";
    for(int ii = 0; ii < n_cells; ii++)
    {
      fileVTK << "9\n";
    }
  
    // Closing VTK file
    fileVTK.close();
  } 
  else { 
    std::cout << " There was an error opening file! In export_mesh_VTK()\n";
  }
}

// ---------------------------------------------

void exporter::export_partpercell_VTK(const char* filename)
{
  // 1) create a mesh file with a certain name, using the function export_mesh_VTK()
  export_mesh_VTK(filename);

  // 2) open this file again in append mode and add the required field (particles 
  // per cell in this case)
  std::ofstream fileVTK;
  fileVTK.open(filename, std::ios::app); // open the file (destroy if exists)

  size_t n_particles;

  // Write stuff
  fileVTK << "\n";
  fileVTK << "POINT_DATA " << 4*p_mesh->get_n_cells() << "\n";
  fileVTK << "SCALARS particles_per_cell float 1\n";
  fileVTK << "LOOKUP_TABLE default\n";
  for(size_t id_c=0; id_c<p_mesh->get_n_cells(); ++id_c)
  {
    n_particles = p_mesh->cells.at(id_c).particles.size();
    fileVTK << n_particles <<" "<< n_particles 
            <<" "<< n_particles <<" "<< n_particles <<"\n";
  }

  // Closing VTK file
  fileVTK.close();
} 

// ---------------------------------------------

void exporter::plot_particles_PNG(const char* filename)
{
  // Plots the particles on a PNG image, using lodepng.
  // The image is divided in two parts: above we have the y and below the z

  // Define some colors..
  int red[4]   = {254, 0, 0, 254};
  int green[4] = {0, 254, 0, 254};
  int blue[4]  = {0, 0, 254, 254};
  int color_now[4] = {0, 0, 0, 254};

  // First of all, find the domain limits
  double x_min, x_max, y_min, y_max, z_min, z_max; // domain limits
  p_mesh->get_domain_box(x_min, x_max, y_min, y_max, z_min, z_max);
  
  // Parameters for image
  //const size_t w  = 510; // width  [pixel]
  const size_t w  = 1000; // width  [pixel]
  const size_t h1  = round(w*(y_max - y_min)/(x_max - x_min)); // height [pixel]
  const size_t h2  = round(w*(z_max - z_min)/(x_max - x_min)); // thickness [pixel]
  const size_t b  = 10;  // border [pixel]
  if(b < 1){
    std::cerr << "ATTENTION!!!!! BORDER b MUST BE BIGGER THAN 1, OTHERWISE SOME ERROR MIGHT "
              << "APPEAR WHEN PLOTTING BORDERS WITH LINEWIGTH 2 !!!!" << std::endl;
  }
 
  const size_t w_nob = w - 2*b; // width without borders
  const size_t h1_nob = h1 - 2*b; // heigth, for y axis without borders
  const size_t h2_nob = h2 - 2*b; // heigth, for z axis  without borders
 
  // Create image vector
  std::vector<unsigned char> imageXY;
  std::vector<unsigned char> imageXZ;
  std::vector<unsigned char> imageXX;

  imageXY.resize(w*h1*4);
  imageXZ.resize(w*h2*4);


  // Fill the image
  size_t pos;

  double X1, X2, Y1, Y2, Z1, Z2, Xpart, Ypart, Zpart; // working variables
  size_t X1p, X2p, Y1p, Y2p, Z1p, Z2p, Xpp, Ypp, Zpp; // working variables

  cell* p_cell;

  // For each cell, draw its borders!
  for(size_t id_c = 0; id_c < p_mesh->cells.size(); ++id_c) {
    // 1) convert the corners positions (double) to sizes in pixel (int)
    // 2) upper-left corresponds to point (0,0) in the image!
    // 3) draw each side of each cell
    p_cell = &(p_mesh->cells.at(id_c));

    X1 = p_cell->XYZcorners[0];    X2 = p_cell->XYZcorners[1];
    Y1 = p_cell->XYZcorners[2];    Y2 = p_cell->XYZcorners[3];
    Z1 = p_cell->XYZcorners[4];    Z2 = p_cell->XYZcorners[5];

    // Positions in pixels
    X1p = round((X1 - x_min)/(x_max - x_min)*w_nob) + b;
    X2p = round((X2 - x_min)/(x_max - x_min)*w_nob) + b;
    Y1p = round((Y1 - y_min)/(y_max - y_min)*h1_nob) + b;
    Y2p = round((Y2 - y_min)/(y_max - y_min)*h1_nob) + b; // check the scaling!!!!
    Z1p = round((Z1 - z_min)/(z_max - z_min)*h2_nob) + b;
    Z2p = round((Z2 - z_min)/(z_max - z_min)*h2_nob) + b;
 
    // Correcting Y and Z so that they start from the top!
    Y1p = h1 - Y1p;
    Y2p = h1 - Y2p;
    Z1p = h2 - Z1p;
    Z2p = h2 - Z2p;

    // Now plot each line!!
    for(size_t pp = X1p; pp < X2p; ++pp) { // horizontal lines
      // XY image
      write_pixel(imageXY, pp, Y1p, w, green);
      write_pixel(imageXY, pp, Y1p+1, w, green); // linewidth 2
      write_pixel(imageXY, pp, Y2p, w, green);
      write_pixel(imageXY, pp, Y2p-1, w, green); // linewidth 2

      // XZ image
      write_pixel(imageXZ, pp, Z1p, w, green);
      write_pixel(imageXZ, pp, Z1p+1, w, green); // linewidth 2
      write_pixel(imageXZ, pp, Z2p, w, green);
      write_pixel(imageXZ, pp, Z2p-1, w, green); // linewidth 2
    }

    for(size_t pp = Y2p; pp < Y1p; ++pp) { // vertical lines. Recall Y and Z are inverted!
      // XY image
      write_pixel(imageXY, X1p, pp, w, green);
      write_pixel(imageXY, X1p+1, pp, w, green);
      write_pixel(imageXY, X2p, pp, w, green);
      write_pixel(imageXY, X2p+1, pp, w, green);
    }
    for(size_t pp = Z2p; pp < Z1p; ++pp) { // vertical lines. Recall Y and Z are inverted!
      // XZ image
      write_pixel(imageXZ, X1p, pp, w, green);
      write_pixel(imageXZ, X1p+1, pp, w, green);
      write_pixel(imageXZ, X2p, pp, w, green);
      write_pixel(imageXZ, X2p+1, pp, w, green);
    }

    // The grid is plotted. Now plot the particles!
    for(size_t id_p = 0; id_p < p_cell->particles.size(); ++id_p) {
      Xpart = p_cell->particles.at(id_p).pos[0];
      Ypart = p_cell->particles.at(id_p).pos[1];
      Zpart = p_cell->particles.at(id_p).pos[2];

      Xpp = round((Xpart - x_min)/(x_max - x_min)*w_nob) + b;
      Ypp = round((Ypart - y_min)/(y_max - y_min)*h1_nob) + b; // check the scaling!!!!
      Zpp = round((Zpart - z_min)/(z_max - z_min)*h2_nob) + b; // check the scaling!!!!

      // Invert the Y and the Z
      Ypp = h1 - Ypp;
      Zpp = h2 - Zpp;

      // CHECK: if particle is out of the domain, DO NOT PLOT IT!
      if((Xpp >= w) || (Xpp < 0) || (Ypp >= h1) || (Ypp < 0) || (Zpp >= h2) || (Zpp < 0)) {
        continue; // Do not plot this particle
      }

      if(id_c%2 == 0) {
        color_now[0] = red[0]; color_now[1] = red[1]; color_now[2] = red[2]; color_now[3] = red[3];
      } else {
        color_now[0] = blue[0]; color_now[1] = blue[1]; color_now[2] = blue[2]; color_now[3] = blue[3];
      }

      // XY image      
      write_pixel(imageXY, Xpp, Ypp, w,   color_now); // linewidth 2
      write_pixel(imageXY, Xpp+1, Ypp, w, color_now); // linewidth 2
      write_pixel(imageXY, Xpp-1, Ypp, w, color_now); // linewidth 2
      write_pixel(imageXY, Xpp, Ypp+1, w, color_now); // linewidth 2
      write_pixel(imageXY, Xpp, Ypp-1, w, color_now); // linewidth 2
      // XZ image
      write_pixel(imageXZ, Xpp, Zpp, w,   color_now); // linewidth 2
      write_pixel(imageXZ, Xpp+1, Zpp, w, color_now); // linewidth 2
      write_pixel(imageXZ, Xpp-1, Zpp, w, color_now); // linewidth 2
      write_pixel(imageXZ, Xpp, Zpp+1, w, color_now); // linewidth 2
      write_pixel(imageXZ, Xpp, Zpp-1, w, color_now); // linewidth 2
    }

    // ------   song time   -------------------------------------------
    // Port Royal! Dark widow on the seeeeeea
    // Port Royal! Whooo ho ho hooo hooo ho hooo hoooo ho hoooooooooo
    // ----------------------------------------------------------------
  }

  // Concatenate the images
  std::vector<unsigned char> image_cat;
  image_cat.reserve( imageXY.size() + imageXZ.size() ); // preallocate memory
  image_cat.insert( image_cat.end(), imageXY.begin(), imageXY.end() );
  image_cat.insert( image_cat.end(), imageXZ.begin(), imageXZ.end() );

//  The following is a backup way.. the other was throwing some weird error
//
//  std::vector<unsigned char> image_cat;
//  image_cat.resize( imageXY.size() + imageXZ.size() ); // preallocate memory
//
//  size_t id = 0;
//
//  for(size_t ii = 0; ii < imageXY.size(); ++ii)
//  {
//    image_cat.at(id) = imageXY.at(ii);
//    id++;
//  }
//  for(size_t ii = 0; ii < imageXZ.size(); ++ii)
//  {
//    image_cat.at(id) = imageXZ.at(ii);
//    id++;
//  }

  // Encode and save the image
  std::vector<unsigned char> buffer;

  unsigned error = lodepng::encode(buffer, image_cat, w, h1+h2);
  if(error) {
    std::cout << "encoder error " << error << ": "<< lodepng_error_text(error) << std::endl;
  }

  lodepng::save_file(buffer, filename);
}

// ---------------------------------------------

void exporter::write_pixel(std::vector<unsigned char>& img, int x, int y, int w, int RGBA[])
{
  // Just a function to make everything a little bit neater
   int pos = 4*(x + y*w);
   img.at(pos+0) = RGBA[0];   // R
   img.at(pos+1) = RGBA[1];   // G
   img.at(pos+2) = RGBA[2];   // B
   img.at(pos+3) = RGBA[3];   // alpha  
}
