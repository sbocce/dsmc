#include <iostream>
#include <fstream>
#include <sstream>
#include <cmath>

#include "exporter.h"
#include "lodepng.h"

exporter::exporter(mesh* p_msh) : p_mesh(p_msh) { }

// ---------------------------------------------

void exporter::export_mesh_VTK(const char* filename)
{
  cell* p_cell_now; // pointer to cell
  double x1now, x2now, x3now, x4now;
  double y1now, y2now, y3now, y4now;

  size_t n_cells = p_mesh->get_n_cells();

  std::ofstream fileVTK;
  fileVTK.open(filename, std::ios::trunc); // open the file (destroy if exists)
  if (fileVTK.is_open() == 1) // file correctly initialized
  { 
    // writing VTK stuff
    fileVTK << "# vtk DataFile Version 2.0\n";
    fileVTK << "Generated by VTKer\n";
    fileVTK << "ASCII\n";
    fileVTK << "DATASET UNSTRUCTURED_GRID\n";
    fileVTK << "POINTS " << 4*n_cells << " float\n";
    for(int ii = 0; ii < n_cells; ii++)
    {
      p_cell_now = &(p_mesh->cells.at(ii));
      x1now = p_cell_now->XYZcorners[0];
      x2now = p_cell_now->XYZcorners[1];
      x3now = p_cell_now->XYZcorners[1];
      x4now = p_cell_now->XYZcorners[0];
  
      y1now = p_cell_now->XYZcorners[2];
      y2now = p_cell_now->XYZcorners[2];
      y3now = p_cell_now->XYZcorners[3];
      y4now = p_cell_now->XYZcorners[3];
  
      fileVTK << x1now << " " << y1now << " 0   ";
      fileVTK << x2now << " " << y2now << " 0   ";
      fileVTK << x3now << " " << y3now << " 0   ";
      fileVTK << x4now << " " << y4now << " 0   ";
      fileVTK << "\n";
    }
  
    fileVTK << "\n";
    fileVTK << "CELLS " << n_cells << " " << 5*n_cells << "\n";
    for(int ii = 0; ii < n_cells; ii++)
    {
      fileVTK << "4 ";
      fileVTK << 0 + 4*ii << " ";
      fileVTK << 1 + 4*ii << " ";
      fileVTK << 2 + 4*ii << " ";
      fileVTK << 3 + 4*ii << " ";
      fileVTK << "\n";
    }
  
    fileVTK << "\n";
    fileVTK << "CELL_TYPES " << n_cells << "\n";
    for(int ii = 0; ii < n_cells; ii++)
    {
      fileVTK << "9\n";
    }
  
    // Closing VTK file
    fileVTK.close();
  } 
  else { 
    std::cout << " There was an error opening file! In export_mesh_VTK()\n";
  }
}

// ---------------------------------------------

void exporter::export_partpercell_VTK(const char* filename)
{
  // 1) create a mesh file with a certain name, using the function export_mesh_VTK()
  export_mesh_VTK(filename);

  // 2) open this file again in append mode and add the required field (particles 
  // per cell in this case)
  std::ofstream fileVTK;
  fileVTK.open(filename, std::ios::app); // open the file (destroy if exists)

  size_t n_particles;

  // Write stuff
  fileVTK << "\n";
  fileVTK << "POINT_DATA " << 4*p_mesh->get_n_cells() << "\n";
  fileVTK << "SCALARS particles_per_cell float 1\n";
  fileVTK << "LOOKUP_TABLE default\n";
  for(size_t id_c=0; id_c<p_mesh->get_n_cells(); ++id_c)
  {
    n_particles = p_mesh->cells.at(id_c).particles.size();
    fileVTK << n_particles <<" "<< n_particles 
            <<" "<< n_particles <<" "<< n_particles <<"\n";
  }

  // Closing VTK file
  fileVTK.close();
} 

// ---------------------------------------------

void exporter::plot_particles_PNG(const char* filename)
{
  // Plots the particles on a PNG image, using lodepng

  // Parameters for image
  const unsigned w = 51; // width  [pixel]
  const unsigned h = 40; // height [pixel]
  const unsigned b = 10;  // border [pixel]
 
  const unsigned w_nob = w - 2*b; // width without borders
  const unsigned h_nob = h - 2*b; // width without borders
  
  // Create image vector
  std::vector<unsigned char> image;
  image.resize(w*h*4);

  // Fill the image
  unsigned pos;

  // Plot horizontal line
  for(int xPix = 10; xPix < 50; ++xPix) {
    pos = 4*(xPix + 0*w);   // where 0 is yPix
    image[pos+0] = 0;   // R
    image[pos+1] = 255;   // G
    image[pos+2] = 0;   // B
    image[pos+3] = 255; // alpha
  }

  double x_min, x_max, y_min, y_max, z_min, z_max; // domain limits
  double X1, X2, Y1, Y2, Z1, Z2;       // working variables
  size_t X1p, X2p, Y1p, Y2p, Z1p, Z2p; // working variables

  // First of all, find the domain limits
  p_mesh->get_domain_box(x_min, x_max, y_min, y_max, z_min, z_max);

  // For each cell, draw its borders!
  for(size_t id_c = 0; id_c < p_mesh->cells.size(); ++id_c) {
    // 1) convert the corners positions (double) to sizes in pixel (int)
    // 2) upper-left corresponds to point (0,0) in the image!
    // 3) draw each side of each cell

    X1 = p_mesh->cells.at(id_c).XYZcorners[0];
    X2 = p_mesh->cells.at(id_c).XYZcorners[1];
    Y1 = p_mesh->cells.at(id_c).XYZcorners[2];
    Y2 = p_mesh->cells.at(id_c).XYZcorners[3];
    Z2 = p_mesh->cells.at(id_c).XYZcorners[4];
    Z2 = p_mesh->cells.at(id_c).XYZcorners[5];

    X1p = round((X1 - x_min)/(x_max - x_min)*w_nob) + b;
    X2p = round((X2 - x_min)/(x_max - x_min)*w_nob) + b;
    Y1p = round((Y1 - y_min)/(y_max - y_min)*w_nob) + b;
    Y2p = round((Y2 - y_min)/(y_max - y_min)*w_nob) + b; // check the scaling!!!!

// DEBUG
    double X1m = (X1 - x_min)/(x_max - x_min)*w_nob + b;
    double X2m = (X2 - x_min)/(x_max - x_min)*w_nob + b;
    double Y1m = (Y1 - y_min)/(y_max - y_min)*w_nob + b;
    double Y2m = (Y2 - y_min)/(y_max - y_min)*w_nob + b; // check the scaling!!!!

//    Z1p = round((Z1 - z_min)/(z_max - z_min)*h_nob) + b;
//    Z2p = round((Z2 - z_min)/(z_max - z_min)*h_nob) + b;

    // Now plot each line!!
    for(int pp = 0; pp < X2p-X1p; ++pp) { // horizontal lines
     
std::cout << x_min << " " << x_max << " " << y_min << " " << y_max << " " << std::endl;
std::cout << X1p << " " << X2p << " " << Y1p << " " << Y2p << " " << pp << std::endl; 
std::cout << X1m << " " << X2m << " " << Y1m << " " << Y2m << " " << std::endl; 
std::cout << X1 << " " << X2 << " " << Y1 << " " << Y2 << " " <<  std::endl; 

      pos = 4*(pp + Y1p*w);
      image[pos+0] = 0;   // R
      image[pos+1] = 255;   // G
      image[pos+2] = 0;   // B
      image[pos+3] = 255; // alpha     

      pos = 4*(pp + Y2p*w);
      image[pos+0] = 0;   // R
      image[pos+1] = 255;   // G
      image[pos+2] = 0;   // B
      image[pos+3] = 255; // alpha     

    }


    // ------   song time   -------------------------------------------
    // Port Royal! Black widow on the seeeeeea
    // Port Royal! Whooo ho ho hooo hooo ho hooo hoooo ho hoooooooooo
    // ----------------------------------------------------------------
  }

  // Encode and save the image
  std::vector<unsigned char> buffer;

  unsigned error = lodepng::encode(buffer, image, w, h);
  if(error) {
    std::cout << "encoder error " << error << ": "<< lodepng_error_text(error) << std::endl;
  }

  lodepng::save_file(buffer, filename);

}
